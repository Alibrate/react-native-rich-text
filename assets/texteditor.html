<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
  <link href="https://alibrate.github.io/quill-mention/dist/quill.mention.min.css" rel="stylesheet"> <!-- TODO: point to alibrate CDN-->

  <style>
    .app-body {
      margin: 0px;
    }

    .floating-toolbar {
      position: fixed;
      top: 0;
      width: 100%;
      background-color: white;
    }

    #editor {
      border: hidden !important;
    }

    .ql-container {
      font-size: 20px;
    }

    .ql-mention-list-item {
      display: flex;
    }
    .ql-mention-list-item.selected {
      background: #fff;
    }
    .ql-mention-list-item .row {
      display: flex;
      flex-direction: row;
      align-items: center;
    }
    .ql-mention-list-item .text {
      font-weight: bold;
      font-size: 14px;
      color: #333;
      vertical-align: middle;
      display: inline-block;
      line-height: 14px;
      padding-left: 10px;
    }
    .ql-mention-list-item .avatar {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      overflow: hidden;
      display: flex;
    }
    .ql-mention-list-item .picture {
      width: 100%;
      border-radius: 0 !important;
      object-fit: cover;
    }

    .ql-editor a, .ql-snow .ql-editor a {
      text-decoration: none;
    }
    .ql-mention-denotation-char, a {
      color: #06c;
    }
  </style>
</head>

<body class="app-body">
<div id="editor"></div>

<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
<script src="https://alibrate.github.io/quill-mention/dist/quill.mention.min.js"></script> <!-- TODO: point to alibrate CDN-->

<script inline>
  /* Tip: una buena manera de mantener este archivo es abrirlo directamente en el navegador. */

  // este es un placeholder de un método que servirá para diferir la muestra de los resultados de la api
  let renderMentionsList = null;

  try {
    const mentionModuleOptions = {
      allowedChars: /^[A-Za-z\s]*$/,
      mentionDenotationChars: ['@'],
      source: function (searchTerm, renderList) {
        if (!renderMentionsList) {
          // siendo que no podemos esperar la respuesta de la api, diferimos la ejecución del callback mediante una variable global
          renderMentionsList = renderList
        }

        if (searchTerm.length === 0) {
          return
        }

        emitEvent({
          type: 'mention',
          value: searchTerm
        })
      },
      renderItem: function (item) {
        return '<span class="row">' +
                '<span class="avatar">' +
                '<img class="picture" src="' + item.picture + '" alt="avatar" />' +
                '</span>' +
                '<span class="text">' + item.username + '</span>' +
                '</span>'
      }
    }

    const editor = new Quill('#editor', {
      modules: {
        toolbar: null,
        mention: mentionModuleOptions
      },
      placeholder: 'Comparte un texto o una foto',
      theme: 'snow',
    });

    // Toda vez que se edita el contenido, se envia el contenido a React Native
    editor.on('text-change', () => {
      emitEvent({
        type: 'content-change',
        value: editor.getContents()
      });
    });

    // Recepción de mensajes de React Native
    handleExternalEvents(editor);
  } catch (e) {
    emitEvent({
      type: 'error',
      value: "Error initializing editor"
    });
  }

  function emitEvent(event) {
    window.postMessage(JSON.stringify(event), '*');
  }

  function handleExternalEvents(editor) {
    document.addEventListener('message', ({data}) => {
      if (data.substr(0, 7) === '$image$') {
        handleImage(editor, data);
      } else if (data[0] === '$') {
        applyFormat(editor, data)
      } else if (data[0] === '{') {
        handleObject(editor, data)
      } else if (data[0] === '<') {
        editor.setContents(editor.clipboard.convert(data, 'silent'))
      } else {
        editor.focus()
      }
    });
  }

  function handleImage(editor, data) {
    const base64 = data.data.substr(7);
    const { index } = editor.getSelection();
    editor.insertEmbed(index, 'image', base64);
  }

  function handleObject(editor, data) {
    const content = JSON.parse(data);
    const isMentionsList = typeof content.mentions !== 'undefined'
    if(isMentionsList) {
      renderMentionsList(content.mentions.slice(0, 7));
      emitEvent({
        value: content.mentions
      });
      return;
    }

    editor.setContents(content);
  }

  function applyFormat(editor, data) {
    const updatedSelector = data.slice(1, data.length - 1);
    const currentFormat = editor.getFormat();
    switch (updatedSelector) {
      case 'bold': {
        editor.format(updatedSelector, !currentFormat.bold, 'user');
        break;
      }
      case 'italic': {
        editor.format(updatedSelector, !currentFormat.italic, 'user');
        break;
      }
      case 'underline': {
        editor.format(updatedSelector, !currentFormat.underline, 'user');
        break;
      }
      case 'size': {
        const updatedFormat = currentFormat.size === 'large' ? null : 'large';
        editor.format('size', updatedFormat, 'user');
        break;
      }
      case 'h1': {
        const updatedFormat = currentFormat.header === 1 ? null : 1;
        editor.format('header', updatedFormat, 'user');
        break;
      }
      case 'ul': {
        const updatedFormat = currentFormat.list === 'bullet' ? null : 'bullet';
        editor.format('list', updatedFormat, 'user');
        break;
      }
      case 'ol': {
        const updatedFormat = currentFormat.list === 'ordered' ? null : 'ordered';
        editor.format('list', updatedFormat, 'user');
        break;
      }
      case 'code-block': {
        editor.format(updatedSelector, !currentFormat['code-block'], 'user');
        break;
      }
      default:
        break;
    }
  }
</script>
</body>
</html>
